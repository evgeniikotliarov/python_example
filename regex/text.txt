Тревога загрязнения пространства имен!
Вместо этого,
связывайте имена через их модули (подробно описанные идентификаторы, с указанием их происхождения):
import module<br/>
module.name<br/>

или импортируйте длинные названия модулей через алиас :
import long_module_name as mod<br/>
mod.name<br/>

или явно импортируйте только те имена, которые нужны:
from module import name<br/>
name<br/>

Заметьте, что эта форма не годится для использования в интерактивном интерпретаторе, где вы можете захотеть отредактировать и перезагрузить («reload( )») модуль.

Модули и скрипты

Чтобы сделать одновременно импортируемый модуль и исполняемый сценарий:
if __name__ == '__main__':<br/>
    # script code here<br/>

Когда его импортируете, атрибут модуля __name__ установлен как имя файла без расширения ".py". Так код по условию if не будет работать, когда модуль импортируется. Когда же вы исполняете скрипт, атрибут __name__ устанавливается в значение "__main__", и код скрипта будет работать.
За исключением некоторых специальных случаев, вам не следует помещать весь код в верхнем уровне. Спрячьте код в функции, классы, методы, и закройте его с помощью if __name__ == '__main__'.


Структура модуля

"""module docstring"""<br/>
<br/>
# imports<br/>
# constants<br/>
# exception classes<br/>
# interface functions<br/>
# classes<br/>
# internal functions & classes<br/>
<br/>
def main(...):<br/>
    ...<br/>
<br/>
if __name__ == '__main__':<br/>
    status = main()<br/>
    sys.exit(status)<br/>

Вот так должен быть структурирован модуль.

Обработка командной строки

Пример: cmdline.py:
#!/usr/bin/env python<br/>
<br/>
"""<br/>
Module docstring.<br/>
"""<br/>
<br/>
import sys<br/>
import optparse<br/>
<br/>
def process_command_line(argv):<br/>
    """<br/>
    Return a 2-tuple: (settings object, args list).<br/>
    `argv` is a list of arguments, or `None` for ``sys.argv[1:]``.<br/>
    """<br/>
    if argv is None:<br/>
        argv = sys.argv[1:]<br/>
<br/>
    # initialize the parser object:<br/>
    parser = optparse.OptionParser(<br/>
        formatter=optparse.TitledHelpFormatter(width=78),<br/>
        add_help_option=None)<br/>
<br/>
    # define options here:<br/>
    parser.add_option(      # customized description; put --help last<br/>
        '-h', '--help', action='help',<br/>
        help='Show this help message and exit.')<br/>
<br/>
    settings, args = parser.parse_args(argv)<br/>
<br/>
    # check number of arguments, verify values, etc.:<br/>
    if args:<br/>
        parser.error('program takes no command-line arguments; '<br/>
                     '"%s" ignored.' % (args,))<br/>
<br/>
    # further process settings & args if necessary<br/>
<br/>
    return settings, args<br/>
<br/>
def main(argv=None):<br/>
    settings, args = process_command_line(argv)<br/>
    # application code here, like:<br/>
    # run(settings, args)<br/>
    return 0         # success<br/>
<br/>
if __name__ == '__main__':<br/>
    status = main()<br/>
    sys.exit(status)<br/>


mail@mail.ru
Пакеты

package/<br/>
    __init__.py<br/>
    module1.py<br/>
    subpackage/<br/>
        __init__.py<br/>
        module2.py<br/>

Используйте для организации ваших проектов.
Снижают затраты на поиск пути при загрузке.
Уменьшают конфликты импорта имен.

Пример:
import package.module1<br/>
from package.subpackage import module2<br/>
from package.subpackage.module2 import name<br/>

В Python 2.5 у нас теперь абсолютные и относительные импорты через future import:
from __future__ import absolute_import<br/>

Я не достаточно глубоко пока еще разобрался в этом, так что мы опустим эту часть нашей дискуссии.


Простое лучше сложного

Во-первых, отладка дважды труднее написания кода. Следовательно, если вы пишете код настолько умно, насколько возможно, вы, по определению, не достаточно умны, чтобы отлаживать его.
—Brian W. Kernighan, co-author of The C Programming Language and the «K» in «AWK»

Другими словами, сохраняйте простоту ваших программ!

Не изобретайте колесо

Перед написанием любого кода:
Посмотрите стандартную библиотеку Python.
Проверьте Python Package Index («Сырная лавка») http://cheeseshop.python.org/pypi
(видимо, намек на скетч о сырной лавке, подобное нашел в Вики-учебнике — примеч. перев.)
Поищите в сети. Google ваш друг.


Ссылки

«Python Objects», Fredrik Lundh,
http://www.effbot.org/zone/python-objects.htm
«How to think like a Pythonista», Mark Hammond,
http://python.net/crew/mwh/hacks/objectthink.html
«Python main() functions», Guido van Rossum,
http://www.artima.com/weblogs/viewpost.jsp?thread=4829
«Python Idioms and Efficiency»,
http://jaynes.colorado.edu/PythonIdioms.html
«Python track: python idioms»,
http://www.cs.caltech.edu/courses/cs11/material/python/misc/python_idioms.html
«Be Pythonic», Shalabh Chaturvedi,
http://shalabh.infogami.com/Be_Pythonic2
«Python Is Not Java», Phillip J. Eby,
http://dirtsimple.org/2004/12/python-is-not-java.html
«What is Pythonic?», Martijn Faassen,
http://faassen.n--tree.net/blog/view/weblog/2005/08/06/0
«Sorting Mini-HOWTO», Andrew Dalke,
http://wiki.python.org/moin/HowTo/Sorting
«Python Idioms», http://www.gungfu.de/facts/wiki/Main/PythonIdioms
«Python FAQs», http://www.python.org/doc/faq/
